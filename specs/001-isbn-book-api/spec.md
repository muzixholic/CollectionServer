# 기능 명세서: 미디어 정보 API 서버

**기능 브랜치**: `001-isbn-book-api`  
**작성일**: 2025-11-16  
**수정일**: 2025-11-16  
**상태**: 초안  
**요구사항**: 다양한 미디어 유형(도서, Blu-ray, DVD, 음악 앨범)의 바코드/ISBN을 입력받아 해당 미디어의 상세 정보를 반환하는 통합 API 서버를 개발합니다. 단일 REST API 엔드포인트(GET /items/{barcode})로 ISBN-10/13, UPC, EAN-13 바코드를 받아 바코드 형식에서 자동으로 미디어 유형을 감지하고 적절한 외부 데이터 소스(Google Books API, Kakao Book Search API, Aladin API, TMDb, OMDb API, MusicBrainz API, Discogs API)를 우선순위에 따라 조회합니다. 내부 PostgreSQL 데이터베이스를 먼저 확인하고, 없을 경우 외부 API를 조회한 후 결과를 데이터베이스에 저장하는 Database-First 아키텍처를 사용합니다. C# 최신 버전, ASP.NET Core 최신 버전, Entity Framework Core 최신 버전을 기술 스택으로 사용하며, 적절한 오류 처리, 캐싱, 속도 제한 및 HTTP 상태 코드를 포함해야 합니다.

## 사용자 시나리오 및 테스트

### 사용자 스토리 1 - 개발자의 미디어 조회 통합 (우선순위: P1)

미디어 수집 또는 라이브러리 관리 애플리케이션을 개발하는 개발자는 바코드/ISBN만 제공하여 자신의 서비스에 다양한 미디어(도서, Blu-ray, DVD, 음악 앨범) 데이터를 신속하게 통합하고 싶어 하며, 여러 외부 API 통합 및 미디어 유형 감지 로직을 직접 관리할 필요가 없어야 합니다.

**이 우선순위가 중요한 이유**: 이것이 API의 핵심 가치 제안입니다. 다른 애플리케이션이 단일 엔드포인트로 쉽게 모든 미디어 정보를 검색할 수 있게 해줍니다. 이것 없이는 API가 목적을 이루지 못합니다.

**독립적 테스트**: 유효한 바코드/ISBN으로 API를 호출하고 완전한 미디어 데이터를 받아 즉시 개발자 가치를 제공할 수 있습니다.

**승인 시나리오**:

1. **주어진** 개발자가 API에 접근할 수 있을 때, **그들이** 유효한 ISBN-13으로 `/items/{barcode}`에 GET 요청을 보내면, **그들은** JSON 형식의 완전한 도서 정보와 함께 200 상태 코드를 받습니다
2. **주어진** 개발자가 유효한 UPC 바코드로 API를 조회할 때, **요청이** 처리되면, **그들은** 자동으로 감지된 미디어 유형(Blu-ray, DVD 또는 음악 앨범)의 데이터를 받습니다
3. **주어진** 개발자가 ISBN-10으로 API를 조회할 때, **요청이** 처리되면, **그들은** ISBN-13으로 정규화된 도서 데이터를 받습니다
4. **주어진** 개발자가 EAN-13 바코드를 제공할 때, **시스템이** 형식을 분석하면, **978/979로 시작하는 경우** 도서로 처리하고 **그렇지 않으면** 영상/음악 미디어로 처리합니다
5. **주어진** 개발자가 API를 자신의 애플리케이션에 통합할 때, **그들이** 유효한 바코드로 요청하면, **Database-First 아키텍처와 캐싱으로 인해 응답이** 합리적인 시간 내에 도착합니다

---

### 사용자 스토리 2 - 최종 사용자의 미디어 발견 (우선순위: P1)

이 API로 구동되는 애플리케이션의 최종 사용자는 바코드로 다양한 미디어(도서, Blu-ray, DVD, 음악 앨범)를 검색하거나 조회하고 (예: 바코드 스캔 또는 수동 입력) 정보에 입각한 결정을 내릴 수 있도록 해당 미디어에 대한 완전한 정보를 받고 싶습니다.

**이 우선순위가 중요한 이유**: 사용자 가치를 직접 지원합니다. 최종 사용자가 모든 유형의 미디어 세부정보를 발견할 수 있도록 하는 것은 모든 미디어 컬렉션 애플리케이션에 필수적입니다.

**독립적 테스트**: 다양한 미디어 유형의 바코드를 제공하고 모든 관련 필드가 정확한 정보와 함께 반환되는지 확인하여 완전히 테스트할 수 있습니다.

**승인 시나리오**:

1. **주어진** 최종 사용자가 도서 ISBN 번호를 가지고 있을 때, **그들이** 이 API를 사용하는 애플리케이션에 입력하면, **그들은** 도서의 제목, 저자, 표지 이미지 및 설명을 봅니다
2. **주어진** 최종 사용자가 Blu-ray/DVD UPC 바코드를 스캔할 때, **데이터가** 검색되면, **그들은** 영화 제목, 감독, 출연진, 런타임, 등급 및 커버 아트를 봅니다
3. **주어진** 최종 사용자가 음악 앨범 UPC를 입력할 때, **시스템이** 처리하면, **그들은** 앨범 제목, 아티스트, 트랙 목록, 재생 시간 및 커버 아트를 봅니다
4. **주어진** 미디어가 다양한 정보가 있는 여러 외부 데이터베이스에 존재할 때, **데이터가** 우선순위에 따라 검색되면, **가장 완전하고 정확한 정보가** 반환됩니다
5. **주어진** 최종 사용자가 인기 있는 미디어를 검색할 때, **API가** 데이터를 검색하면, **응답에** 성공적으로 로드되는 커버 이미지 URL이 포함됩니다

---

### 사용자 스토리 3 - 오류 처리 및 우아한 폴백 (우선순위: P1)

개발자 또는 최종 사용자는 잘못된 바코드 형식, 미디어 미발견 또는 임시 서비스 문제로 인해 미디어 조회가 실패한 이유를 이해하고 입력을 수정하거나 다시 시도할 수 있도록 도움이 되는 오류 메시지를 받아야 합니다.

**이 우선순위가 중요한 이유**: 강력한 오류 처리는 사용자 경험에 직접 영향을 미치고 애플리케이션 실패를 방지합니다. 명확한 오류 메시지 없이는 사용자가 서비스를 효과적으로 사용할 수 없습니다.

**독립적 테스트**: 잘못된 바코드와 존재하지 않는 미디어를 제출하고 적절한 오류 메시지와 HTTP 상태 코드가 반환되는지 확인하여 완전히 테스트할 수 있습니다.

**승인 시나리오**:

1. **주어진** 잘못된 바코드 형식이 제공될 때, **API가** 입력을 검증하면, **400 Bad Request 상태가** 바코드 형식 요구사항에 대한 명확한 설명과 함께 반환됩니다
2. **주어진** 유효한 바코드 형식이지만 미디어와 일치하지 않을 때, **API가** 우선순위에 따라 모든 외부 소스를 조회한 후, **404 Not Found 상태가** 미디어를 찾을 수 없음을 나타내는 메시지와 함께 반환됩니다
3. **주어진** 특정 미디어 유형의 모든 외부 API가 일시적으로 사용할 수 없을 때, **요청이** 이루어지면, **적절한 5xx 오류가** 임시 서비스 문제를 나타내는 메시지와 함께 반환됩니다
4. **주어진** 바코드 형식이 모호할 때 (예: 13자리 EAN), **시스템이** 감지 로직을 적용하면, **적절한 미디어 유형이** 자동으로 결정됩니다

---

### 사용자 스토리 4 - Database-First 아키텍처를 통한 성능 최적화 (우선순위: P1)

자주 접근하는 미디어에 API를 사용하는 개발자는 불필요한 외부 API 호출을 피하고 지연 시간을 줄이며 애플리케이션 응답성을 개선해야 합니다. 시스템은 내부 PostgreSQL 데이터베이스를 먼저 확인하고, 없을 경우에만 외부 API를 조회한 후 결과를 저장하여 이후 요청을 빠르게 처리합니다.

**이 우선순위가 중요한 이유**: Database-First 아키텍처는 성능을 크게 개선하고 외부 서비스에 대한 의존성을 줄이며 데이터 일관성을 보장합니다. 이는 시스템의 핵심 설계 원칙입니다.

**독립적 테스트**: 동일한 바코드를 여러 번 요청하고 데이터베이스 히트로 인해 후속 요청이 훨씬 빠르게 반환되는지 확인하여 완전히 테스트할 수 있습니다.

**승인 시나리오**:

1. **주어진** 미디어가 이전에 요청되고 데이터베이스에 저장되었을 때, **동일한 바코드가** 다시 요청되면, **응답 시간이** 훨씬 빠릅니다 (데이터베이스에서 제공됨)
2. **주어진** 새로운 바코드가 처음으로 요청될 때, **시스템이** 데이터베이스를 확인하고 미발견하면, **외부 API를** 조회하고 결과를 데이터베이스에 저장합니다
3. **주어진** 외부 API에서 새로운 미디어 정보가 검색될 때, **저장이** 완료되면, **다음 요청부터는** 데이터베이스에서 즉시 반환됩니다
4. **주어진** 동일한 바코드에 대한 여러 동시 요청이 도착할 때, **처리되면, 외부 API가** 한 번만 호출되고 모든 요청이 동일한 데이터를 받습니다

---

### 사용자 스토리 5 - 외부 데이터 소스 우선순위 및 폴백 (우선순위: P1)

API를 사용하는 개발자는 각 미디어 유형에 대해 가장 신뢰할 수 있고 완전한 데이터를 받기 위해 시스템이 우선순위에 따라 여러 외부 데이터 소스를 조회하고, 한 소스가 실패하거나 불완전한 데이터를 반환할 경우 다음 소스로 폴백할 수 있어야 합니다.

**이 우선순위가 중요한 이유**: 여러 외부 API의 가용성과 데이터 품질은 다양하므로, 우선순위 기반 폴백 메커니즘은 높은 성공률과 데이터 품질을 보장합니다.

**독립적 테스트**: 특정 외부 API를 시뮬레이션하여 실패하게 하고 시스템이 다음 우선순위 소스로 자동 폴백하는지 확인하여 완전히 테스트할 수 있습니다.

**승인 시나리오**:

1. **주어진** 도서 바코드가 요청될 때, **시스템이** 데이터를 검색하면, **Google Books API, Kakao Book Search API, Aladin API 순서로** 시도합니다
2. **주어진** Blu-ray/DVD 바코드가 요청될 때, **시스템이** 데이터를 검색하면, **TMDb를 먼저 조회하고 실패 시 OMDb API를** 시도합니다
3. **주어진** 음악 앨범 바코드가 요청될 때, **시스템이** 데이터를 검색하면, **MusicBrainz API를 먼저 조회하고 실패 시 Discogs API를** 시도합니다
4. **주어진** 첫 번째 우선순위 API가 불완전한 데이터를 반환할 때, **시스템이** 평가하면, **다음 소스에서** 추가 정보를 보완하거나 더 완전한 데이터를 사용합니다
5. **주어진** 모든 우선순위 소스가 실패할 때, **시스템이** 시도를 완료하면, **404 Not Found 상태를** 적절한 메시지와 함께 반환합니다

---

### 사용자 스토리 6 - 속도 제한을 통한 공정한 API 사용 (우선순위: P2)

API를 사용하는 개발자는 사용 제한을 이해하고 서비스 성능 저하를 경험하는 대신 속도 제한을 초과할 때 요청이 정상적으로 거부되어야 합니다.

**이 우선순위가 중요한 이유**: 속도 제한은 악용을 방지하고 모든 사용자에게 공정한 접근을 보장하지만 핵심 기능과 별도로 구현할 수 있습니다.

**독립적 테스트**: 속도 제한을 초과하는 요청을 보내고 적절한 429 상태 코드와 속도 제한 헤더가 반환되는지 확인하여 완전히 테스트할 수 있습니다.

**승인 시나리오**:

1. **주어진** 클라이언트가 속도 제한 범위 내에 있을 때, **그들이** 요청하면, **모든 요청이** 정상적으로 처리됩니다
2. **주어진** 클라이언트가 속도 제한 할당을 초과할 때, **그들이** 추가 요청을 하면, **429 Too Many Requests 상태가** 반환됩니다
3. **주어진** 클라이언트가 속도 제한 오류를 받을 때, **응답 헤더를** 확인하면, **언제 다시 시도할 수 있는지에 대한 정보를** 봅니다 (Retry-After)

---

### 엣지 케이스

#### 도서 관련 엣지 케이스
- ISBN 번호가 형식상 유효하지만 체크 디지트 오류가 있을 경우는 어떻게 되나요? (400 Bad Request를 반환해야 함)
- 여러 저자가 있는 도서를 어떻게 처리하나요? (배열 형식으로 모두 반환해야 함)
- 외부 API가 동일한 ISBN에 대해 충돌하는 정보를 반환할 경우는 어떻게 되나요? (우선순위가 높은 소스 또는 가장 완전한 데이터를 사용해야 함)
- 표지 이미지를 사용할 수 없는 도서를 어떻게 처리하나요? (이미지 URL에 대해 null을 반환하거나 사용할 수 없음을 표시해야 함)
- 사용자가 공백, 대시 또는 기타 서식이 있는 ISBN을 제공할 경우는 어떻게 되나요? (정규화하고 수용해야 함)

#### Blu-ray/DVD 관련 엣지 케이스
- 동일한 영화가 Blu-ray와 DVD 두 형식 모두에 존재할 경우는 어떻게 되나요? (각각을 별도의 미디어 항목으로 처리하고 형식 필드로 구분해야 함)
- 여러 감독이 있는 영화를 어떻게 처리하나요? (배열 형식으로 모두 반환해야 함)
- 출연진 정보가 매우 많을 경우는 어떻게 되나요? (주요 출연진만 반환하거나 제한을 설정해야 함)
- 등급 정보가 없거나 미등급 콘텐츠일 경우는 어떻게 되나요? (null 또는 "Unrated"를 반환해야 함)
- UPC가 Special Edition, Director's Cut 등 다양한 버전의 동일 영화를 가리킬 경우는 어떻게 되나요? (각 버전을 별도로 처리하고 제목/설명에 버전 정보를 포함해야 함)

#### 음악 앨범 관련 엣지 케이스
- 컴필레이션 앨범에 여러 아티스트가 있을 경우는 어떻게 되나요? ("Various Artists"로 표시하거나 모든 아티스트를 배열로 반환해야 함)
- 트랙 목록이 매우 긴 앨범(박스 세트 등)을 어떻게 처리하나요? (모든 트랙을 반환하되 페이지네이션 고려)
- 앨범의 디스크가 여러 개일 경우는 어떻게 되나요? (디스크 번호와 함께 트랙 정보를 구조화해야 함)
- 재발매 또는 리마스터 버전을 어떻게 구분하나요? (원본 발매일과 재발매 정보를 모두 포함해야 함)

#### 바코드 감지 관련 엣지 케이스
- 13자리 바코드가 978 또는 979로 시작하지만 실제로는 도서가 아닌 경우는 어떻게 되나요? (도서 API를 먼저 시도하고 실패 시 다른 미디어 유형으로 폴백해야 함)
- 체크 디지트가 잘못된 UPC/EAN 바코드를 어떻게 처리하나요? (400 Bad Request를 반환하고 형식 오류를 명확히 표시해야 함)
- 숫자가 아닌 문자가 포함된 바코드를 어떻게 처리하나요? (정규화를 시도하고, 실패 시 400 Bad Request를 반환해야 함)

#### 시스템 및 데이터 관련 엣지 케이스
- 모든 외부 데이터 소스를 사용할 수 없을 경우는 어떻게 되나요? (데이터베이스에 있으면 반환, 없으면 적절한 메시지와 함께 503 Service Unavailable을 반환해야 함)
- 한 외부 데이터베이스에는 존재하지만 다른 우선순위 높은 데이터베이스에는 존재하지 않는 미디어를 어떻게 처리하나요? (404를 반환하기 전에 우선순위 순서대로 모든 소스를 시도해야 함)
- 동일한 바코드에 대한 동시 요청이 많을 때 데이터베이스 저장을 어떻게 처리하나요? (중복 저장을 방지하기 위한 락 메커니즘 또는 트랜잭션 처리가 필요함)
- 외부 API에서 검색한 데이터가 부분적으로만 사용 가능할 경우는 어떻게 되나요? (사용 가능한 필드만 저장하고 반환하며, 누락된 필드는 null로 표시해야 함)

## 요구사항

### 기능 요구사항

#### 바코드 처리 및 미디어 유형 감지
- **FR-001**: 시스템은 REST API(`GET /items/{barcode}`)를 통해 ISBN-10, ISBN-13, UPC-12, EAN-13 형식의 바코드 입력을 수용해야 합니다
- **FR-002**: 시스템은 외부 데이터베이스를 조회하기 전에 바코드 형식 및 체크 디지트를 검증해야 합니다
- **FR-003**: 시스템은 바코드 형식을 기반으로 미디어 유형을 자동으로 감지해야 합니다:
  - ISBN-10 (10자리): 도서
  - ISBN-13 (13자리, 978/979 시작): 도서
  - UPC (12자리): Blu-ray, DVD 또는 음악 앨범
  - EAN-13 (13자리, 978/979가 아닌 경우): Blu-ray, DVD 또는 음악 앨범
- **FR-004**: 시스템은 일관성을 위해 ISBN-10을 ISBN-13 형식으로 정규화해야 합니다
- **FR-005**: 시스템은 바코드에서 공백, 대시 및 기타 서식 문자를 제거하여 정규화해야 합니다

#### Database-First 아키텍처
- **FR-006**: 시스템은 외부 API를 조회하기 전에 내부 PostgreSQL 데이터베이스를 먼저 확인해야 합니다
- **FR-007**: 시스템은 데이터베이스에서 미디어를 찾으면 즉시 반환해야 합니다
- **FR-008**: 시스템은 데이터베이스에서 미디어를 찾지 못하면 외부 API를 우선순위에 따라 조회해야 합니다
- **FR-009**: 시스템은 외부 API에서 검색한 미디어 정보를 데이터베이스에 저장한 후 반환해야 합니다
- **FR-010**: 시스템은 동일한 바코드에 대한 동시 요청 시 중복 외부 API 호출 및 데이터베이스 저장을 방지해야 합니다

#### 외부 데이터 소스 통합
- **FR-011**: 시스템은 도서 정보를 검색하기 위해 다음 순서로 외부 API를 조회해야 합니다:
  1. Google Books API
  2. Kakao Book Search API
  3. Aladin API
- **FR-012**: 시스템은 Blu-ray/DVD 정보를 검색하기 위해 다음 순서로 외부 API를 조회해야 합니다:
  1. TMDb (The Movie Database)
  2. OMDb API
- **FR-013**: 시스템은 음악 앨범 정보를 검색하기 위해 다음 순서로 외부 API를 조회해야 합니다:
  1. MusicBrainz API
  2. Discogs API
- **FR-014**: 시스템은 한 외부 API가 실패하거나 불완전한 데이터를 반환할 경우 다음 우선순위 소스로 폴백해야 합니다
- **FR-015**: 시스템은 모든 외부 소스가 실패한 경우에만 404 Not Found를 반환해야 합니다

#### 미디어별 정보 반환
- **FR-016**: 시스템은 도서에 대해 다음 정보를 반환해야 합니다:
  - 제목, 저자(배열), 출판사, 출판일, 설명, 표지 이미지 URL, 카테고리(배열), 페이지 수, 언어, 정규화된 ISBN
- **FR-017**: 시스템은 Blu-ray/DVD에 대해 다음 정보를 반환해야 합니다:
  - 제목, 감독(배열), 출연진(배열), 런타임(분), 발매일, 스튜디오, 등급(예: PG-13), 시놉시스, 커버 아트 URL, 장르(배열), 형식(Blu-ray/DVD)
- **FR-018**: 시스템은 음악 앨범에 대해 다음 정보를 반환해야 합니다:
  - 앨범 제목, 아티스트(배열), 발매일, 레이블, 트랙 목록(배열), 총 재생 시간, 커버 아트 URL, 장르(배열)
- **FR-019**: 시스템은 누락되거나 불완전한 데이터를 우아하게 처리해야 합니다 (예: 일부 미디어는 커버 이미지 또는 설명이 없을 수 있음)
- **FR-020**: 시스템은 미디어 유형을 나타내는 `mediaType` 필드를 응답에 포함해야 합니다 (book, bluray, dvd, music)

#### 오류 처리
- **FR-021**: 시스템은 유효하지 않은 바코드 형식에 대해 설명적인 오류 메시지와 함께 400 Bad Request 오류를 반환해야 합니다
- **FR-022**: 시스템은 유효한 바코드가 모든 외부 데이터베이스에서 미디어와 일치하지 않을 때 404 Not Found 오류를 반환해야 합니다
- **FR-023**: 시스템은 모든 외부 데이터베이스 조회가 실패할 때 적절한 5xx 오류를 반환하여 클라이언트가 바코드 검증 오류와 구별할 수 있도록 해야 합니다
- **FR-024**: 시스템은 클라이언트가 무엇이 잘못되었는지 그리고 어떻게 해결할 수 있는지 이해하도록 도와주는 의미 있는 오류 메시지를 제공해야 합니다

#### API 관리 및 성능
- **FR-025**: 시스템은 악용을 방지하기 위해 API 엔드포인트에서 속도 제한을 구현해야 합니다
- **FR-026**: 시스템은 속도 제한을 초과할 때 재시도 정보를 포함하여 429 Too Many Requests 상태를 반환해야 합니다
- **FR-027**: 시스템은 다양한 시나리오에 대해 적절한 HTTP 상태 코드(200, 400, 404, 429, 503 등)를 사용해야 합니다
- **FR-028**: 시스템은 JSON 요청/응답 형식을 기본 콘텐츠 유형으로 지원해야 합니다
- **FR-029**: 시스템은 C# 최신 안정 버전, ASP.NET Core 최신 안정 버전, Entity Framework Core 최신 안정 버전을 사용해야 합니다
- **FR-030**: 시스템은 PostgreSQL을 데이터베이스로 사용해야 합니다

### 주요 엔티티

- **미디어 항목**: 바코드로 식별되는 고유한 미디어(도서, Blu-ray, DVD, 음악 앨범)를 나타내며, 미디어 유형에 따라 다음 속성을 포함합니다:
  - **공통 속성**: 바코드, 미디어 유형, 제목, 발매일/출판일, 커버 이미지 URL, 장르/카테고리, 설명/시놉시스
  - **도서 속성**: 저자, 출판사, 페이지 수, 언어, 정규화된 ISBN
  - **Blu-ray/DVD 속성**: 감독, 출연진, 런타임, 스튜디오, 등급, 형식
  - **음악 앨범 속성**: 아티스트, 레이블, 트랙 목록, 총 재생 시간
- **외부 데이터 소스 설정**: 각 미디어 유형에 대한 외부 API 우선순위 및 폴백 순서를 정의합니다
- **속도 제한 할당**: 시간 창에 대해 구성된 제한을 기준으로 클라이언트당 (API 키, IP 또는 구독 계층별) API 사용을 추적합니다

## 성공 기준

### 측정 가능한 결과

- **SC-001**: API는 외부 데이터베이스에 존재하는 유효한 바코드의 95%+ 에 대해 완전한 미디어 정보를 반환합니다 (모든 미디어 유형 포함)
- **SC-002**: API 응답 시간은 데이터베이스 히트의 경우 500ms 미만, 외부 API에 대한 초기 쿼리의 경우 2초 미만입니다
- **SC-003**: API는 100% 정확도로 바코드 형식을 올바르게 검증하고 미디어 유형을 감지합니다 (유효하지 않은 형식을 올바르게 거부하고 유효한 형식을 수용합니다)
- **SC-004**: Database-First 아키텍처는 일반적인 사용 패턴에서 불필요한 외부 API 호출을 최소 80% 줄입니다
- **SC-005**: 우선순위 기반 폴백 메커니즘은 단일 외부 소스 실패 시에도 90%+ 의 성공률을 보장합니다
- **SC-006**: 속도 제한은 인증된 클라이언트당 분당 최소 100개의 요청을 허용하면서 악용을 방지합니다
- **SC-007**: 오류 응답에는 개발자가 추가 문서 없이 문제를 이해할 수 있도록 하는 명확하고 실행 가능한 메시지가 포함되어 있습니다
- **SC-008**: API는 외부 데이터베이스 실패를 우아하게 처리하여 적절한 상태 코드를 반환하고 클라이언트가 재시도 논리를 구현할 수 있도록 합니다

## 가정

- **A-001**: 지정된 외부 API들(Google Books API, Kakao Book Search API, Aladin API, TMDb, OMDb API, MusicBrainz API, Discogs API)을 사용할 수 있으며 대상 사용자 기반에 충분한 미디어 커버리지를 제공합니다
- **A-002**: PostgreSQL 데이터베이스를 배포 환경에서 사용할 수 있습니다
- **A-003**: 속도 제한은 표준 기법(토큰 버킷, 슬라이딩 윈도우 등)을 사용하여 구현할 수 있으며 처음에는 정교한 분산 추적이 필요하지 않습니다
- **A-004**: 바코드 검증은 ISBN-10/13, UPC, EAN-13 표준을 따르며 적절한 체크 디지트 검증이 있습니다
- **A-005**: 대부분의 조회 미디어는 커버 이미지를 사용할 수 있습니다. 누락된 이미지는 허용되며 API 응답을 차단하지 않아야 합니다
- **A-006**: 표준 웹 성능 기대치가 적용됩니다 (1초 미만의 응답 시간은 허용 가능; 초기 외부 API 호출에는 100ms 미만이 필요하지 않습니다)
- **A-007**: API는 완벽한 데이터 일관성보다 가용성을 우선시합니다 (외부 API를 일시적으로 사용할 수 없는 경우 데이터베이스에 저장된 데이터를 반환하는 것은 허용 가능합니다)
- **A-008**: 각 미디어 유형의 외부 API는 합리적인 속도 제한 정책을 가지고 있으며, 우선순위 기반 접근 방식으로 이를 관리할 수 있습니다
- **A-009**: C#, ASP.NET Core, Entity Framework Core의 최신 안정 버전은 이 프로젝트의 요구사항을 충족하며 필요한 기능을 제공합니다
- **A-010**: UPC/EAN 바코드만으로 Blu-ray, DVD, 음악 앨범을 구분하는 것은 외부 API 응답 데이터에 의존하며, 필요시 여러 미디어 유형 API를 순차적으로 시도할 수 있습니다
